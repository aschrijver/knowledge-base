                                                         _ooλoo_
                                                        o111111o
                                                        01" λ "10
                                                        (| -_- |)
                                                         O\ λ /O
                                                     ____/`---'\____
                                                   .   ' \\| |// `.
                                                    / \\||| λ |||// \
                                                  / _||||| -Δ- |||||- \
                                                    | | \\\ - /// | |
                                                  | \_| ''\---/'' | |
                                                   \ .-\__ `-` ___/-. /
                                                ___`. .' /--.--\ `. . __
                                             ."" '< `.___\_<λ>_/___.' >'"".
                                            | | : `- \`.;`\ _ /`;.`/ - ` : | |
                                              \ \ `-. \_ __\ /__ _/ .-` / /
                                      ======`-.____`-.___\_____/___.-`____.-'======
                                                         `=---='


# 101

### From 101 to think functionally:

[0] [The Structure and Interpretation of Computer Programs](https://github.com/allenleein/brains/blob/master/Zen-of-Functional-Programming/(883)The%20Structure%20and%20Interpretation%20of%20Computer%20Programs.pdf)

[1] [The Little Schemer](https://github.com/allenleein/brains/blob/master/Zen-of-Functional-Programming/The_Little_Schemer_4th.pdf)


### Advice for Beginners

**Don't write abstractions first**. 

Haskell programmers love their abstractions, and it's easy to fall into the trap of trying to shoehorn the abstraction into your program. 

Rather, write the program like you would naturally, then when you recognize the patterns (i.e. Monad, Applicative, ...), rewrite it using the abstractions. Use higher order functions to separate similar functionality, and before you know it you have a nice combinator library which describes your problem domain well. 

Reading: 

[For Beginners](https://argumatronic.com/posts/1970-01-01-beginners.html)

[An opinionated guide to Haskell in 2018](https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/)


### Haskell 101

[Practical Haskell programs from scratch - a quick and easy guide](https://www.ahri.net/practical-haskell-programs-from-scratch/#a-repl-read-evaluate-print-loop)

[Practical Haskell](http://seanhess.github.io/) 

[Haskell Study Plan](https://github.com/soupi/haskell-study-plan)

[CIS 194 UPenn 2013](http://www.seas.upenn.edu/~cis194/spring13/lectures.html)

[Haskell Programming From First Principle](https://github.com/allenleein/brains/blob/master/Zen-of-Functional-Programming/Haskell%20Programming%20From%20First%20Principle.pdf)

### Reads for Experienced

[Haskell for Readers](http://haskell-for-readers.nomeata.de/)

[Haskell's kind system - a primer](https://diogocastro.com/blog/2018/10/17/haskells-kind-system-a-primer/)

